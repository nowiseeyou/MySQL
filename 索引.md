## MySql索引 ##

	https://juejin.im/post/6844903555141206030

MySql支持诸多存储引擎，而各种存储引擎对索引的支持也是各不相同，因此MySql 数据库支持多种索引类型，如 Btree索引，哈希索引，全文索引等。

Mysql官方对索引定义为： 索引（index） 是帮助 Mysql 高效获取数据的数据结构。

#### 目的 ####

索引的目的在于提高查询效率。

#### 原理 ####

所有索引原理都一样，通过不断缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机事件变成顺序事件，也就是我们总是通过同一种查找方式来锁定数据。

数据库也是一样的，但显然要复杂许多，因为不仅面临着等值查询，还有范围查询（>,<,between），模糊查询（like）,并集查询（or）,多值匹配（in [in 本质上属于多个 or]）等。


### MySql 优化 ###

#### 配置优化 ####

- `innodb_buffer_pool_size`
	

	这是安装InnoDB 后第一个应该设置的选项。缓冲池是数据和索引缓存的地方： 这个值越大越好，这能保证你在大多数的读取操作时使用的是内存而不是硬盘。典型的值是 5-6G（8G内存），20-25G（32G内存），100-120G（128G内存）
- `innodb_log_file_size`

	这是redo 日志的大小。redo日志被用于确保写操作快速而可靠并且在奔溃时恢复。一直到Mysql5.1,他都难以调整，因为一方面你想让他更大来提高性能，另一方面你想让它更小来使得崩溃后更快恢复。Mysql5.5之后，崩溃恢复的性能得到了很大提升，这样你就可以同时拥有较高的写入性能和崩溃恢复性能了。一直到Mysql5.5, redo日志的总尺寸被限定在 4GB(默认可以有两个log文件)。这在Mysql5.6 被提高了。如果你知道你的应用程序需要频繁写入数据并且你使用的是Mysql5.6, 你可以一开始就把他设置成 4G

- `max_connections`

	如果悄经常看到 "Too many connections" 错误，是因为 max_connections 值太低了。这非常常见 因为应用程序没有正确关闭链接，你需要比默认的 151 连接数更大的值。max_connection  被设高了（例如1000或更高）之后一个主要缺陷是当服务器运行 1000 个或更高的活动事务时会变的没有响应。在应用程序里使用连接池或者在Mysql里使用进程池有助于解决这一问题。

### InnoDB配置 ###

- `innodb_file_per_table`

	这项设置告知 InnoDB 是否需要将所有表的数据和索引存放在共享表格空间里（innodb_file_per_table = OFF） 或者每张表的数据单独放在一个.ibd 文件（innodb_file_per_table = ON ）。每张表一个文件允许你在 drop,truncate或者rebuild 表时回收磁盘空间。这对于一些高级特性也是有必要的，比如数据压缩。但是它不会带来任何性能收益。你不想让每张表一个文件的主要场景是：非常多的表（比如 10k+）。 MySQL5.6 中，这个属性默认值是ON。

- `innodb_flush_log_at_trx_commit`

	默认值为 1，表示 InnoDB 完全支持ACID特性。当你的主要关注点是数据安全的时候，这个值是最合适的，比如在一个主节点上。但是对于磁盘(读写) 速度较慢的系统，它会带来很巨大的开销，因为每次将改变 flush  到 redo 日志都需要额外的 fsyncs。将它的值设置为 2 会导致不太可靠（reliable） 因为提交的事务仅仅几秒才 flush一次到 redo 日志，但对于一些场景是可以接受的，比如对于主节点的备份节点这个值是可以接受的。如果值为 0 速度就更快了，但在系统崩溃时 可能丢失一些数据：只适用于备份节点

- `innodb_flush_method`

	这项配置决定了数据和日志 写入硬盘的方式。一般来说，如果你的硬件 RAID 控制器，并且其独立缓存采用了 write-back 机制，并有着电池断电保护，那么应该设置配置为 O_DIRECT ；否则，大多数情况下 应将其设置为 fdatasync(默认值) 。sysbench 是一个可以帮助你解决这个选项的好工具

- `innodb_log_buffer_size`

	这项配置决定了为尚未执行的事务分配的缓存。 其默认值（1MB）一般来说已经够用了，但是如果你的事务包含有二进制或者大文本字段的话，这点缓存很快就会被填满并触发额外的 I/O操作。看看 Innodb_log_waits 状态变量，如果它不是0，增加 innodb_log_buffer_size

### 其他设置 ###

- `query_cache_size`

	query cache （查询缓存）是一个众所周知的瓶颈，甚至在并发并不多的时候也是如此。最佳选项是将其从一开始就停用， 设置 query_cache_size = 0 (现在Mysql5.6 默认值) 并利用其他方法加速查询 ： 优化索引，增加拷贝分散负载或者启用额外的缓存(比如 memcache 或 redis) 。 如果你已经为你的应用启用了 query cache 并且还没有发现任何问题，query cache 可能对你有用。这是如果你想停用它，那就得小心了。

- `log_bin`

	如果你想让数据服务器充当主节点的备份节点，那么开启二进制日志是必须的。如果这么做了以后，还别忘了设置 server_id 为一个唯一的值。就算只有一个服务器，如果你想做基于时间点的数据恢复，这（开启二进制日志）也是很有用的 ： 从你最近的备份中恢复（全量备份）， 并应用二进制日志中的修改（增量备份）。二进制日志一旦创建就将永久保存。所以如果你不想让磁盘空间耗尽，你可以用 PURGE BINARY LOGS 来清除旧文件，或者设置 expire_logs_days 来指定过多少天 日志被自动清除。记录二进制日志不是没有开销的，所以如果你在非主节点的复制节点上不需要它的话，建议关闭这个选项。

- `skip_name_resolve`

	当客户端连接数据库服务器时，服务器会进行主机解析，并且当 DNS 很慢时，建立连接也会很慢。因此建议在启动服务器时，关闭 skip_name_resolve 选项而不进行 DNS 查找。唯一局限是之后 GRANT 语句中只能使用 ip地址了，因此在添加这项设置到一个已有系统中格外小心。

### SQL调优 ###

#### 慢查询优化基本步骤 ####

- 先运行看看是否真的很慢，注意设置 SQL_NO_CACHE
- where 条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的  `where` 都应用到表中，返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高。
- explain 查看执行计划，是否与 1 预期一致，（从锁定记录较少的表开始查询）
- order by limit 形式的 sql 语句 让排序的表优先查
- 了解业务方使用场景
- 加索引时参照索引的几大原则
- 观察结果，不符合预期继续从 0 分析

#### 常用调优手段（explain） ####

**explain 各个字段的含义**

- id : 表示SQL执行的顺序的标识，SQL从大到小的执行
- select_type ： 表示查询中每个select 子句的类型
- table : 显示这一行的数据是关于哪张表的，有时不是真实的表名
- type : 表示MySQL 在表中找到所需行的方式，又称 “访问类型” 。常用类型有 ： ALL,index,range,ref,eq_ref,const,system,NULL (从左到右， 性能从差到好)
- possible_keys : 指出MySQL 能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用
- key : key 列显示MySQL 实际决定使用的键（索引），如果没有选择索引，键是 NULL。
- key_len : 表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度 （key_len 显示的值 为索引字段的最大可能长度，并非实际使用长度，即 key_len 是根据表定义计算而得，不是通过表内检索出的）
- ref : 表示上述表的连接匹配条件，即那些列，或常量被用于查找索引列上的值
- row : 表示 MySQL 根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数，理论上行数越少，查询性能越好
- Extra ： 该列包含 Mysql 解决问题的详细信息

**EXPLAIN的特性**

- EXPLAIN 不会告诉关于触发器，存储过程的信息或用户自定义的函数对查询的影响情况
- EXPLAIN 不考虑各种 cache
- EXPLAIN 不能显示 MySQL 在执行查询时所作的优化工作
- 部分统计信息是估算的，并非精确值
- EXPLAIN 只能解释 SELECT 操作，其他操作要重写为 SELECT 后查看执行计划


### MySQL索引操作 ###

- ALTER TABLE

	# ALTER TABLE 用来创建普通索引，UNIQUE 索引或 PRIMARY KEY 索引。

	ALTER TABLE table_name ADD INDEX index_name(column_list)
	
	ALTER TABLE table_name ADD UNIQUE (column_list)

	ALTER TABLE table_name ADD PRIMARY KEY (column_list)

- CREATE INDEX

	# CREATE INDEX 可对表增加普通索引 或 UNIQUE 索引

	CREATE INDEX index_name ON table_name(column_list)

	CREATE UNIQUE INDEX index_name ON table_name(column_list)


- 删除索引

	# DROP INDEX index_name ON table_name

	ALTER TABLE table_name DROP INDEX index_name

	ALTER TABLE table_name DROP PRIMARY KEY

- 查看索引

	SHOW INDEX FROM table_name

### 注意 ###

- 索引不是越多越好
- 区分主键和索引
- 理解索引结构原理
- 理解查询索引原理
- 尽量使用前缀索引




