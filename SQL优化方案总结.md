## Sql优化方案 ##

### 一、SQL语句性能优化 ###

    http://cn.voidcc.com/question/p-sgayybci-gq.html

1. 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 以及 order by 涉及的列上建立索引。
2. 应尽量避免在 where 子句中对字段进行 null 值判断，创建表时 NULL 是默认值，但大多数使用 NOT NULL，或者使用一个特殊的值，如0，-1,作为默认值。
3. 应尽量避免在 WHERE 子句中 使用 ！= 或 <> 操作符，Mysql只有对以下操作符才使用索引 ：< ,  <= , = , > , >= , BETWEEN , IN 以及 LIKE。
4. 应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫码，可以使用 UNION 合并查询 ： `SELECT  id  FROM  table WHERE num = 10 UNION ALL select id from table WHERE num =20;`
5. in 和 not in 也要慎用，否则会导致全表扫描，对于连续的数值，能用BETWEEN 就不要用 IN 了 `SELECT id FROM t WHERE num BETWEEN 1 AND 3;` 
6. 下面的查询也将导致全表扫描： `SELECT id FROM table WHERE name LIKE '%abc%';` 或者 `SELECT id FROM table WHERE name LIKE '%abc';` 才会用到索引。
7. 如果在 where 子句中使用参数，也会导致全表扫码。
8. 应尽量避免在 where 子句中对字段进行表达式操作，应尽量避免在 where 子句中对字段进行函数操作。
9. 很多时候用 exists 代替 in 是一个好的选择 ： `SELECT num From  a WHERE num in (SELECT num FROM b);` 用下面的语句替换 ： `SELECT num FROM a WHERE exists(SELECT 1 FROM b WHERE num = a.num);`
10. 索引固然可以提高相应的 SELECT 的效率，但同时也降低了 insert 以及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建所以需要慎重考虑，视具体情况而定，一个表的索引数最好不要超过 6 个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。
11. 尽量避免更新 ClusteredIndex（聚合索引）数据列，因为 ClusteredIndex(聚合索引)数据列的顺序就是表记录的物理存储顺序，一单该列值改变将会导致整个表记录的顺序调整，会耗费相当大的资源。若应用系统需要频繁更新 ClusteredIndex（聚合索引）数据列，那么需要考虑是否应将该索引建为 ClusteredIndex（聚合索引）。
12. 尽量使用数字型字段，若致函数值信息的字段尽量不要设计字符型，这会降低查询和连接的性能，并会增加存储开销。
13. 尽可能的使用 varchar/nvarchat 代替 char/nchar ，因为首先边长字段存储空间小，可以节省空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。
14. 最好不要使用 "" 返回所有，`SELECT FROM table`，用具体的字段列表代替  "*" ，不要返回不需要的字段。
15. 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。
16. 使用表的别名（alias） : 当在 SQL 语句中连接多个表时，请使用表的别名并把别名前缀于每个 Column 上，这样一来，就可以减少解析的时间并减少哪些由Column 歧义引起的语法错误。
17. 使用 "临时表" 暂存中间结果，简化SQL 语句的重要方法就是采用临时表暂存中间结果，但是临时表的好处远不止这些，将临时结果暂存在临时表，后面查询就在 tempdb 中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中 "共享锁" 阻塞 "更新锁"，减少了阻塞，提高了并发性能。
18. 一些SQL 语句的应加上 nolock ，读 ， 写是会相互阻塞的，为了提高并发性能，对于一些查询，可以寄上 nolock ， 这样读的时候可以允许写，但缺点是可能督导未提交的脏数据。使用 nolock ! 3原则。查询的结果用于 "增，删，改"的不加 nolock ! 查询的表属于频繁发生页分裂的，慎用 nolock ! 使用临时表一样可以保存 "数据前影" ，起到类似 Oracle 的 undo 表空间的功能，能采用临时表提高并发性能，不要用 nolock 。
19. 常见的简化规则如下：不要超过5个以上的表连接（JOIN），考虑使用临时表或表变量存放中间结果。少用子查询，视图嵌套不要过深，一般视图嵌套不超过2个为宜。
20. 将需要查询的结果预先计算好放在表中，查询的时候再SELECT。 这在 MYSQL7.0以前是最重要的手段，例如 医院住院费计算。
21. 用 OR 的子句可以分解成多个查询，并通过 UNION 连接多个查询，他们的速度只同是否使用索引有关，如果查询需要用到联合索引，用 UNION ALL 执行的效率更高。多个OR 的子句没有用到索引，改写成 UNION 的形式再视图与索引匹配。一个关键的问题是否用到**索引**。
22. 在 IN 后面值的列表中，将出现最频繁的值放在前面，出现最少的放在最后面，减少判断的次数。
23. 尽量将数据的处理工作放在服务器上，减少网络开销，如使用存储过程。存储过程是编译好，优化过，并且被组织到一个执行规划里，且存储在数据库中的SQL语句，是控制流语言的集合，速度当然快。反复执行的动态 SQL ， 可以使用临时存储过程，该过程（临时表）被放在 tempdb中。
24. 当服务器的内存够多时，配置线程数量 = 最大连接数 +5 ，这样能发挥最大的效率，否则使用配置线程数量 < 最大连接数启用SQL SERVERD 的线程池来解决，如果还是数量 = 最大连接数 +5 ，严重的损害服务器的性能。
25. 查询的关联同写的顺序

	(A=B,B="号码")

		SELECT  a.persionMemberID,* 
		FROM chineseresume a,personmember b 
		WHERE personMemberID = b.referenceid and a.personMemberID ='JCNPRH39681';
	
	(A=B,B="号码"，A="号码")

		SELECT a.personMemberID,* FROM chineseresume a,personmember b 
		WHERE a.personMemberID = b.referenceid and a.personMemberID = "JCNPRH39681" 
		AND b,referenceid = "JCNPRH39681";

	(B = "号码" ， A = "号码")

		SELECT a.personMemberID,* FROM chinkeseresume a , personmember b
		WHERE b.referenceid = "JCNPRH39681" 
		ADN a.personMemmberID = 'JCNPRH39681';



26. 尽量使用 `exists` 代替 `SELECT COUNT(1)` 来判断是否存在记录，`count` 函数只有在统计表中所有行数时使用，而且 count(1) 比 count（*） 更有效率。
27. 尽量使用 `>=,<=`，不要使用 `> <`。
28. 索引的使用范围：索引的创建要与应用结合考虑，建议打的OLTP 表不要超过 6 个索引；尽可能的使用索引字段作为查询条件，尤其是聚簇索引，必要时可以通过index index_name来潜在估值指定索引；避免对大表查询时进行的 table scan(表扫描) ，必要时考虑新建索引；在使用索引字段作为条件时，如果该索引是联合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则改索引将不会被使用；要注意索引的维护，周期性重建索引，重新编译存储过程。
29. 下列SQL条件中的列都建有恰当的索引，但执行速度却非常慢：

    	SELECT * FROM record WHERE substring(card_no,1,4) = '5378';(13s)
		SELECT * FROM record WHERE amount/30 <= 100 ;(11s)
		SELECT * FROM record WHERE convert(char(10),date,112) = '19991201';(10s)

分析：

WHERE 子句中对列的任何操作结果都是在SQL 运行时逐列计算得到的，因此它不得不进行表搜索，而没有使用该列上面的索引；如果这些结果在查询编译时就能得到，那么就可以被SQL优化器优化，使用索引，避免表搜索，因此将SQL重写：
		
		SELECT * FROM record WHERE card_no LIKE "5378%";(< 1s)
		SELECT * FROM record WHERE amount <= 1000*30;(< 1s)
		SELECT * FROM record WHERE date = '1999/12/01'(< 1s)

30. 当有一批处理的插入或更新时，用批量插入或批量更新，绝不会一条条记录的取更新。
31. 在所有的存储过程中，能够用SQL语句的，绝不要用循环去实现！（eg:列出上个月的每一天，挽回用connect by 去递归查询一下，绝不会去用上个月的第一天到最后一天）
32. 选择最有效率的表名顺序（只在基于规则的优化器中生效）：oracle的解析器按照从右到左的顺序处理FROM子句中的表名，FROM 子句中写在最后的表（基础表 driving table）将被最先处理，在FROM 子句中包含多个表的情况下，你必须选择记录条数最少的表作为基础表。如果有三个以上的表连接查询，那就需要选择交叉表（intersection table）作为基础表，交叉表是指那个被其他表所引用的表。
33. 提高GROUP BY 语句的效率，可以通过将不需要的记录在 GROUP BY 之前过滤掉。下面两个查询返回相同的结果，但是第二个明显快了许多。

低效：

    	SELECT  JOB,AVG(SAL) FROM EMP
		GROUP BY JOB HAVING JOB
		HAIVNG JOB = 'PRESIDENT' 
		OR JOB = "MANAGER";

高效 ： 

    	SELECT JOB,AVG(SAL) FROM EMP
		WHERE JOB = 'PRESIDENT'
		OR JOB = 'MANAGER'
		GROUP BY JOB;

34. sql 语句用大写，因为 oracle 总是先解析sql 语句，把小写的字母换成大写的再执行。
35. 别名的使用，别名是大型数据库的应用技巧，就是表名、列名在查询中以一个字母为别名，查询的速度比建链接表快1.5倍。【没太懂】
36. 避免使用临时表，除非却有需要，否则应尽量避免使用临时表，相反，可以使用变量代替；大多数时候（99%），表变量驻扎在内存中，因此速度比临时表更快，临时表驻扎在 TempDb数据库中，因此临时表上的操作需要跨数据库通信，速度自然慢。
37. 最好不要使用触发器，触发一个触发器，执行一个触发器事件本身就是一个耗费资源的过程；如果能够使用约束实现的，尽量不要使用触发器；不要为不同的触发事件（INSER,UPDATE和DELETE）使用相同的触发器；不要在触发器中使用事务型代码。
38. 避免死锁，在你的存储过程和触发器中访问同一个表时总是以相同的顺序；事务应尽可能的缩短，在一个事务中应尽量减少涉及到的数据量，永远不要在事务中等待用户输入。
39. 索引创建规则：

表主键，外检必须有索引；

数据量超过 300 的表应该有索引；

经常与其他表进行连接的表，在连接字段上应该建立索引；

经常出现在 WHERE 子句中的字段，特别是大表的字段，应该建立索引；

索引应该建在选择性高的字段上；

索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；

复合索引的建立需要进行仔细的分析，尽量考虑用单字段索引代替；

正确选择复合索引中的主列字段，一般是选择性较好的字段；

复合索引的几个字段是否经常同时以 AND 方式出现在 WHERE 子句中？ 单字段查询是否极少甚至没有？ 如果是，则可以建立复合索引，否则考虑单字段索引；

如果复合索引中包含的字段进程单独出现在 WHERE 子句中，则分解为多个单字段索引；

如果复合索引包含的字段超过3 个，哪个自信考虑其必要性，考虑减少复合的字段；

如果既有单字段索引，避免对执行计划造成负面影响；

表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销。另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大。尽量不要对数据库中某个含有大量重复的值的字段建立索引。

40. MySql 查询优化总结 ： 使用慢查询日志去发现慢查询，使用执行技术啊去判断查询是否正常运行，总是去测试你的查询看看是否他们运行在最佳状态下。久而久之性能总会变化，避免在整个表上使用 count(*),他可能锁住整张表，使查询保持一致以便后续相似的查询可以使用查询缓存，在适当的情形下使用 GROUP BY 而不是 DISTINCT，WHERE ，GROUP BY 和 GROUP BY 子句中使用有索引的列，保持索引简单，不在多个索引中包含同一个列，有时候MySQL 会使用错误的索引，对于这种情况使用 USE INDEX ，检查使用SQL_MODE = STRICT 的问题，对于激励数小于5的索引字段，在UNION的时候使用 LIMIT 不是使用OR。
为了避免在更新前 SELECT ， 使用 INSERT ON DUPLICATE KEY 或者 INSERT IGNORE，不要用 UPDATE 去实现，不要使用MAX ，使用索引字段和 ORDER BY 子句，LIMIT M，N实际上可以减缓查询在某些情况下，有节制的使用，在WHERE 子句中使用 UNION 代替子查询，在重新启动的MySql，记得温暖你的数据库，以确保你的数据在内存和查询速度快，考虑持久连接，而不是多个连接，减少开销，基准查询，包括使用服务器上的负载，有时候一个简单的查询可以影响其他查询，当负载增加您的服务器上，使用SHOW PROCESSLIST 查看慢的和有问题的查询，在开发环境中产生的镜像数据中，测试的索引可疑的查询
41. Mysql 备份过程：

从二级复制服务器上进行备份，在进行备份期间停止复制，以避免在数据依赖和外键约束上出现不一致。彻底停止MySQL，从数据库文件进行备份。

如果使用MYSQL dump 进行备份，请同时备份二进制日志文件-确保复制没有中断。不要信任LVM快照，这很可能产生数据不一致，将会带来不必要的麻烦。为了更容易的进行单表恢复，以表为单位导出数据 - 如果数据与其他表隔离的。

当使用 mysqldump 时请使用 -opt。 在备份之前检查和优化表。为了更快的进行导入，在导入时临时禁用外键约束。

为了更快的进行导入，在导入时临时禁用唯一性检测，在每一次备份后计算数据库，表以及索引的尺寸，以便更够监控尺寸的增长。

通过自动调度脚本监控复制实例的错误和延迟。定期执行备份。

42. 查询缓冲并不自动处理空格，因此在写SQL 语句时，应尽量减少空格的使用，尤其是在SQL 首和尾的空格（因此，查询缓冲并不自动截取首尾空格）。

43. member 用 mid 做标准进行分表 方便查询么？一般的业务需求中基本上都是以 username 为查询依据，正常应当是 username 做hash 取模来分表吧，分表的话， mysql 的partition 功能就是干这个的，对代码透明的；在代码层面去实现貌似是不合理的。
44. 我们应该为数据库里的每张表都设置一个ID 作为其主键，而且最好的是一个INT 型的（推荐使用 UNSIGNED）， 并设置上自动增加的  AUTO_INCREMENT 标志。
45. 在所有的存储过程和触发器的开始出设置 SET NOCOUNT ON，在结束时设置 SET NOCOUNT OFF。无需在执行过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。
46. Mysql 查询可以启用告诉查询缓存。这是提高数据库性能的有效SQL优化方式之一。当同一个查询被执行多次时，从缓存中提取数据和直接从数据库中返回数据块很多。
47. EXPLAIN SELECT 查询用来追踪查看效果，使用EXPLAIN 关键字可以让你知道 MYSQL 是如何处理你的SQL语句的。这可以帮助你分析你的查询语句或是表结构性能瓶颈，EXPLAIN 的查询结果结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的...等待。
48. 当只要一行数据时，使用 LIMIT 1，当你查询表的时候，你已经知道结果只会有一条结果，但因为你可能需要去 fetch 游标，或是你也许会去检查返回的记录数。在这种情况下，加上LIMIT 1可以增加性能。这样一样，MYSQL数据库引擎会找到一条数据后停止搜索，而不是继续往后查找下一条复合记录的数据。
49. 选择表合适存储引擎：

MYSAM：应用时以读和插入为主，只有少量的更新和删除，并且对事物的完整性，并发性能要求不是很高。

**INNODB**：事务处理，以及并发条件下要求数据的一致性，除了插入和查询外，包括很多的更新和删除（INNODB有效的降低删除和更新导致的锁定）。对于支持事务的INNODB类型的表来说，影响速度的主要原因是 AUTOCOMMIT 默认设置是打开的，而且程序没有显式调用 BEGIN开始事务，导致每插入一条都自动提交，严重影响了速度，可以在执行 sql  前调 begin ，多条 sql 形成一个事务（即使 autocommit打开也可以），将大大提高性能。

50. 优化表的数据类型，选择合适的数据类型：

原则： 更小通常更好，简单就好，所有字段都得有默认值，尽量避免 null。

例如： 数据表设计时候更小的占磁盘空间 尽可能使用更小的整数类型。（mediumint就比int更合适）。

比如时间字段： datetime 和 timestamp ，datetime 占用8个字节，而 timestamp 占用4个字节，只用了一半，而timestamp 表示的范围是 1970-2037适合做更新时间。

MYSQL可以很好的支持大数据量的存取，但是一般来说，数据库中的表越小，在她上面执行的查询就会越快。因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的的宽度设得尽可能小，例如，在定义邮政编码这个字段时，如果将其设置为 char(255) ，显然给数据库增加了不必要的空间，甚至使用varchar这种类型也是多余的，因为 char(6)就可以很好的完成任务了。同样的，如果可以的话，我们应该使用 MEDIUMINT 而不是 BIGINT 来定义整型字段。应该尽量把字段设置为 NOT NULL ，这样在将来执行查询的时候，数据库不用去比较 NULL 值。对于某些文本字段，例如‘省份’ 或者 ‘性别’ ，我们可以将它们定义为 enum 类型，因为在Mysql中，ENUM 类型被当做数值类型来处理，而数值型数据被处理起来的速度要比文本类型数据快得多，这样，我们又可以提高数据库性能。

51. 字符串 数据类型 ： char ， varchar ，text选择区别
52. 任何队列的操作都将导致表扫描，它包括数据库函数，计算表达式等，查询时应尽可能将操作移至等号右边。

### 二、索引优化 ###

1. 对于查询进行优化，应尽量避免全表扫码，首先应考虑在 WHERE 及 order by 涉及的列上建立索引。
2. 应尽量避免在 where 子句中对字段进行 null 判断，否则会导致引擎放弃使用索引而进行全表扫描，如：`SELECT id FROM table_name WHERE num is null;` 可以在 num 上设置默认值为0，确保表中 num 列没有null 值，然后这样查询： `SELECT id FROM WHERE num =0;`。
3. 应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：`SELECT id FROM table_name WHERE num =10 OR num =20;` 可以这样查询：`SELECT id FROM table_name WHERE num = 10 UNION ALL SELECT id FROM table_name WHERE num=20;`
4. 应尽量避免在 where 子句中使用  ！= 或 <>  操作符，否则引擎将放弃使用索引而进行全表扫描。
5. in 和 not in 也要慎用，否则会导致全表扫描，如：`SELECT id FROM table_name WHERE num in(1,2,3);` 对于连续的数值，能用 between 就不用in ： `SELECT id FROM table_name WHERE num BETWEEN 1 AND 3;`。
6. 下面的查询也会导致全表扫描： `SELECT id FROM table_name WHERE name like "a%"`,若要提高效率，可以考虑全文索引。
7. 如果在 where 子句中使用参数,也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能讲访问计划的选择推迟到运行时；它必须在编译时进行选择，然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描： `SELECT id FROM table  WHERE num = @num;` 可以改为强制查询使用索引：`SELECT id FROM table with(index(索引名)) WHERE num = @num;`。
8. 应尽量避免在 WHERE 子句中对字段进行函数操作，这将导致引擎放弃，使用索引而进行全表扫描。如： `SELECT id  FROM table WHERE  num/2 = 100;` 应改为 `SELECT id  FROM table WHERE num = 100*2;`
9. 应尽量避免在 WHERE 子句中对字段进行函数操作，这将导致引擎放弃索引进而全表扫描。如： `SELECT id FROM table substring(name,1,3)='abc';`，name 以 abc 开头的id 应改为： `SELECT id FROM table WHERE name LIKE 'abc%';`
10. **不要**在 where 子句中的 "="左边进行函数，算术运算或其他表达式运算，否则系统将可能无法正确使用索引。
11. 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序一致。
12. 不要写一些没有意义的查询，如果要生成一个空表结构： `SELECT col1,col2 into #table FROM table  WHERE 1 =0;`   这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样 ： `create table #t(...);`
13. 很多时候用 exists 代替 in 是最好的选择 ： `SELECT num FROM a WHERE num IN (SELECT num FROM b);`  应改为 ： `SELECT num FROM a WHERE exists(SELECT 1 FROM b WHERE num = a.num);`
14. 并不是所有所有对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex, male ,female 几乎各一半，那么即使在 sex 上建立了所有也对查询效率起不了作用。
15. 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 以及 update 的效率，因此 insert 或 update 时可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个 ，若太多则应考虑一些不常用的列上建索引是否必要。
16. 尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应该将该索引建立为 clustered 索引。
17. 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会只能加存储开销，这是因为引擎再处理查询和连接时会逐个比较字符串中的每一个字符，而对于数字型而言只需要比较一次就够了。
18. 尽可能的使用  varchar/nvarchar  代替 char/ncahr ，因为首先边长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然会高一些。
19. 任何地方都不要使用 `SELECT * FROM table;`，用具体的字段来代替 "*"，不要返回用不到的任何字段。
20. 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。
21. 避免频繁创建和删除临时表，以减少系统表资源的消耗。
22. 临时表并不是不可使用，适当的使用他们可以使某些例程更有效，例如：当需要重复引用大型表或常用表中的某些数据集时。但是，对于一次性事件，最好使用导出表。
23. 在新建临时表时，如果一次性插入数据量很大，那么可以使用 SELECT INTO 代替 CREATE table，避免造成大量 log，以提高速度；如果数据量不大，为了缓和系统表的资源，应先在crete table ， 然后 insert。
24. 如果使用到了临时表，在存储过程的最后务必将所有的临时表显示删除，先 truncate table,然后 drop table ，这样可以避免系统表较长的时间锁定。




		